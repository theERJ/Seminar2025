<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <title>Mixed Reality Gallery</title>
  <style>
    body {
      margin: 0;
      font-family: Arial, sans-serif;
    }
    button.webvr-ui-button {
      font-family: Arial, sans-serif;
      border: rgb(80,168,252) 2px solid;
      border-radius: 2px;
      background: none;
      height: 55px;
      min-width: 176px;
      display: inline-block;
      position: relative;
      cursor: pointer;
      transition: border 0.5s;
    }
    button.webvr-ui-button:focus {
      outline: none;
    }
    .webvr-ui-logo {
      width: 55px;
      height: 55px;
      position: absolute;
      top: 0;
      left: 0;
    }
    .webvr-ui-svg {
      fill: rgb(80,168,252);
      margin-top: 18px;
      margin-left: 18px;
    }
    .webvr-ui-svg-error {
      fill: rgb(80,168,252);
      display: none;
      margin-top: 14px;
      margin-left: 18px;
    }
    .webvr-ui-title {
      color: rgb(80,168,252);
      position: relative;
      font-size: 18px;
      padding-left: 58px;
      padding-right: 18px;
      transition: color 0.5s;
    }
    button.webvr-ui-button[disabled=true] {
      opacity: 0.5;
    }
    button.webvr-ui-button[disabled=true] > .webvr-ui-logo > .webvr-ui-svg {
      display: none;
    }
    button.webvr-ui-button[disabled=true] > .webvr-ui-logo > .webvr-ui-svg-error {
      display: initial;
    }
    button.webvr-ui-button[error=true] {
      animation: errorShake 0.4s;
    }
    @keyframes errorShake {
      0% { transform: translate(1px, 0) }
      10% { transform: translate(-2px, 0) }
      20% { transform: translate(2px, 0) }
      30% { transform: translate(-2px, 0) }
      40% { transform: translate(2px, 0) }
      50% { transform: translate(-2px, 0) }
      60% { transform: translate(2px, 0) }
      70% { transform: translate(-2px, 0) }
      80% { transform: translate(2px, 0) }
      90% { transform: translate(-1px, 0) }
      100% { transform: translate(0px, 0) }
    }
  </style>
</head>
<body>
  <header>
    <details open>
      <summary>Mixed Reality Gallery</summary>
      <p>
        Thiss sample places a cube, sphere, and torus in mixed reality using passthrough.
        The objects rotate and change color when gazed at. Walk around to view them in your real-world space.
      </p>
    </details>
    <button class="webvr-ui-button" disabled="true" title="No XR headset found.">
      <div class="webvr-ui-title" style="display: initial;">AR NOT FOUND</div>
      <div class="webvr-ui-logo">
        <svg class="webvr-ui-svg" version="1.1" x="0px" y="0px" width="22.8px" height="14.7px" viewBox="0 0 28 18" xml:space="preserve">
          <path d="M26.8,1.1C26.1,0.4,25.1,0,24.2,0H3.4c-1,0-1.7,0.4-2.4,1.1C0.3,1.7,0,2.7,0,3.6v10.7
          c0,1,0.3,1.9,0.9,2.6C1.6,17.6,2.4,18,3.4,18h5c0.7,0,1.3-0.2,1.8-0.5c0.6-0.3,1-0.8,1.3-1.4l
          1.5-2.6C13.2,13.1,13,13,14,13v0h-0.2 h0c0.3,0,0.7,0.1,0.8,0.5l1.4,2.6c0.3,0.6,0.8,1.1,1.3,
          1.4c0.6,0.3,1.2,0.5,1.8,0.5h5c1,0,2-0.4,2.7-1.1c0.7-0.7,1.2-1.6,1.2-2.6 V3.6C28,2.7,27.5,
          1.7,26.8,1.1z M7.4,11.8c-1.6,0-2.8-1.3-2.8-2.8c0-1.6,1.3-2.8,2.8-2.8c1.6,0,2.8,1.3,2.8,2.8
          C10.2,10.5,8.9,11.8,7.4,11.8z M20.1,11.8c-1.6,0-2.8-1.3-2.8-2.8c0-1.6,1.3-2.8,2.8-2.8C21.7
          ,6.2,23,7.4,23,9 C23,10.5,21.7,11.8,20.1,11.8z"></path>
        </svg>
        <svg class="webvr-ui-svg-error" x="0px" y="0px" width="22.8px" height="22.8px" viewBox="0 0 28 28" xml:space="preserve">
          <path d="M17.6,13.4c0-0.2-0.1-0.4-0.1-0.6c0-1.6,1.3-2.8,2.8-2.8s2.8,1.3,2.8,2.8s-1.3,2.8-2.8,2.8
          c-0.2,0-0.4,0-0.6-0.1l5.9,5.9c0.5-0.2,0.9-0.4,1.3-0.8
          c0.7-0.7,1.1-1.6,1.1-2.5V7.4c0-1-0.4-1.9-1.1-2.5c-0.7-0.7-1.6-1-2.5-1
          H8.1 L17.6,13.4z"></path>
          <path d="M10.1,14.2c-0.5,0.9-1.4,1.4-2.4,1.4c-1.6,0-2.8-1.3-2.8-2.8c0-1.1,0.6-2,1.4-2.5
          L0.9,5.1 C0.3,5.7,0,6.6,0,7.5v10.7c0,1,0.4,1.8,1.1,2.5c0.7,0.7,1.6,1,2.5,1
          h5c0.7,0,1.3-0.1,1.8-0.5c0.6-0.3,1-0.8,1.3-1.4l1.3-2.6 L10.1,14.2z"></path>
          <path d="M25.5,27.5l-25-25C-0.1,2-0.1,1,0.5,0.4l0,0C1-0.1,2-0.1,2.6,0.4l25,25c0.6,0.6,0.6,1.5
          ,0,2.1l0,0 C27,28.1,26,28.1,25.5,27.5z"></path>
        </svg>
      </div>
    </button>
  </header>
  <script type="module">
    // WebXRButton and other utilities (from the example)
    class WebXRButton {
      constructor(options) {
        this.options = options;
        this.domElement = document.createElement('button');
        this.domElement.className = 'webvr-ui-button';
        this.domElement.disabled = true;

        this.titleElement = document.createElement('div');
        this.titleElement.className = 'webvr-ui-title';
        this.titleElement.style.display = 'initial';
        this.titleElement.innerText = options.textXRNotFoundTitle;
        this.domElement.appendChild(this.titleElement);

        this.logoElement = document.createElement('div');
        this.logoElement.className = 'webvr-ui-logo';
        this.logoElement.innerHTML = `
          <svg class="webvr-ui-svg" version="1.1" x="0px" y="0px" width="22.8px" height="14.7px" viewBox="0 0 28 18" xml:space="preserve">
            <path d="M26.8,1.1C26.1,0.4,25.1,0,24.2,0H3.4c-1,0-1.7,0.4-2.4,1.1C0.3,1.7,0,2.7,0,3.6v10.7
            c0,1,0.3,1.9,0.9,2.6C1.6,17.6,2.4,18,3.4,18h5c0.7,0,1.3-0.2,1.8-0.5c0.6-0.3,1-0.8,1.3-1.4l
            1.5-2.6C13.2,13.1,13,13,14,13v0h-0.2 h0c0.3,0,0.7,0.1,0.8,0.5l1.4,2.6c0.3,0.6,0.8,1.1,1.3,
            1.4c0.6,0.3,1.2,0.5,1.8,0.5h5c1,0,2-0.4,2.7-1.1c0.7-0.7,1.2-1.6,1.2-2.6 V3.6C28,2.7,27.5,
            1.7,26.8,1.1z M7.4,11.8c-1.6,0-2.8-1.3-2.8-2.8c0-1.6,1.3-2.8,2.8-2.8c1.6,0,2.8,1.3,2.8,2.8
            C10.2,10.5,8.9,11.8,7.4,11.8z M20.1,11.8c-1.6,0-2.8-1.3-2.8-2.8c0-1.6,1.3-2.8,2.8-2.8C21.7
            ,6.2,23,7.4,23,9 C23,10.5,21.7,11.8,20.1,11.8z"></path>
          </svg>
          <svg class="webvr-ui-svg-error" x="0px" y="0px" width="22.8px" height="22.8px" viewBox="0 0 28 28" xml:space="preserve">
            <path d="M17.6,13.4c0-0.2-0.1-0.4-0.1-0.6c0-1.6,1.3-2.8,2.8-2.8s2.8,1.3,2.8,2.8s-1.3,2.8-2.8,2.8
            c-0.2,0-0.4,0-0.6-0.1l5.9,5.9c0.5-0.2,0.9-0.4,1.3-0.8
            c0.7-0.7,1.1-1.6,1.1-2.5V7.4c0-1-0.4-1.9-1.1-2.5c-0.7-0.7-1.6-1-2.5-1
            H8.1 L17.6,13.4z"></path>
            <path d="M10.1,14.2c-0.5,0.9-1.4,1.4-2.4,1.4c-1.6,0-2.8-1.3-2.8-2.8c0-1.1,0.6-2,1.4-2.5
            L0.9,5.1 C0.3,5.7,0,6.6,0,7.5v10.7c0,1,0.4,1.8,1.1,2.5c0.7,0.7,1.6,1,2.5,1
            h5c0.7,0,1.3-0.1,1.8-0.5c0.6-0.3,1-0.8,1.3-1.4l1.3-2.6 L10.1,14.2z"></path>
            <path d="M25.5,27.5l-25-25C-0.1,2-0.1,1,0.5,0.4l0,0C1-0.1,2-0.1,2.6,0.4l25,25c0.6,0.6,0.6,1.5
            ,0,2.1l0,0 C27,28.1,26,28.1,25.5,27.5z"></path>
          </svg>
        </div>
      </button>
    </header>
    <script type="module">
      // WebXR Polyfill for compatibility
      import WebXRPolyfill from 'https://cdn.jsdelivr.net/npm/webxr-polyfill@latest/build/webxr-polyfill.module.js';
      let polyfill = new WebXRPolyfill();

      // XR globals
      let xrButton = null;
      let xrImmersiveRefSpace = null;
      let inlineViewerHelper = null;
      let xrSession = null;
      let hitTestSource = null;

      // WebGL scene globals
      let gl = null;
      let renderer = null;
      let scene = null;

      // Custom scene and renderer classes
      class Scene {
        constructor() {
          this.nodes = [];
          this.time = 0;
        }
        addNode(node) {
          this.nodes.push(node);
        }
        setRenderer(renderer) {
          this.renderer = renderer;
        }
        startFrame() {
          this.time += 1 / 60; // Simulate 60 FPS
        }
        drawXRFrame(frame, pose) {
          if (!pose) return;
          const view = pose.views[0];
          const viewport = frame.session.renderState.baseLayer.getViewport(view);
          gl.viewport(viewport.x, viewport.y, viewport.width, viewport.height);

          gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
          // In MR, we don't set a background color to allow passthrough

          const viewMatrix = view.transform.inverse.matrix;
          const projectionMatrix = view.projectionMatrix;

          // Gaze detection using hit-test
          if (hitTestSource && frame.session) {
            const hitTestResults = frame.getHitTestResults(hitTestSource);
            this.nodes.forEach(node => node.isGazed = false); // Reset gaze state
            if (hitTestResults.length > 0) {
              const hit = hitTestResults[0];
              const hitPose = hit.getPose(xrImmersiveRefSpace);
              const hitPosition = hitPose.transform.position;
              this.nodes.forEach(node => {
                const dx = node.position[0] - hitPosition.x;
                const dy = node.position[1] - hitPosition.y;
                const dz = node.position[2] - hitPosition.z;
                const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                if (distance < 0.5) { // Adjust threshold as needed
                  node.isGazed = true;
                }
              });
            }
          }

          this.nodes.forEach(node => {
            node.draw(viewMatrix, projectionMatrix, this.time);
          });
        }
        endFrame() {}
      }

      class Renderer {
        constructor(gl) {
          this.gl = gl;
          gl.enable(gl.DEPTH_TEST);
        }
      }

      class ShapeNode {
        constructor({ position, type, color, gazeColor }) {
          this.position = position;
          this.type = type; // 'cube', 'sphere', 'torus'
          this.color = color; // [r, g, b]
          this.gazeColor = gazeColor; // [r, g, b]
          this.isGazed = false;
          this.rotation = 0;

          // WebGL setup
          this.program = this.createProgram();
          this.buffers = this.createBuffers();
        }
        createProgram() {
          const vsSource = `
            attribute vec3 aPosition;
            uniform mat4 uModelViewMatrix;
            uniform mat4 uProjectionMatrix;
            void main() {
              gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aPosition, 1.0);
            }
          `;
          const fsSource = `
            precision mediump float;
            uniform vec3 uColor;
            void main() {
              gl_FragColor = vec4(uColor, 1.0);
            }
          `;
          const vertexShader = gl.createShader(gl.VERTEX_SHADER);
          gl.shaderSource(vertexShader, vsSource);
          gl.compileShader(vertexShader);
          const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
          gl.shaderSource(fragmentShader, fsSource);
          gl.compileShader(fragmentShader);
          const program = gl.createProgram();
          gl.attachShader(program, vertexShader);
          gl.attachShader(program, fragmentShader);
          gl.linkProgram(program);
          return program;
        }
        createBuffers() {
          let vertices, indices;
          if (this.type === 'cube') {
            vertices = new Float32Array([
              // Front face
              -0.5, -0.5,  0.5,  0.5, -0.5,  0.5,  0.5,  0.5,  0.5, -0.5,  0.5,  0.5,
              // Back face
              -0.5, -0.5, -0.5, -0.5,  0.5, -0.5,  0.5,  0.5, -0.5,  0.5, -0.5, -0.5,
              // Top face
              -0.5,  0.5, -0.5, -0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5, -0.5,
              // Bottom face
              -0.5, -0.5, -0.5,  0.5, -0.5, -0.5,  0.5, -0.5,  0.5, -0.5, -0.5,  0.5,
              // Right face
               0.5, -0.5, -0.5,  0.5,  0.5, -0.5,  0.5,  0.5,  0.5,  0.5, -0.5,  0.5,
              // Left face
              -0.5, -0.5, -0.5, -0.5, -0.5,  0.5, -0.5,  0.5,  0.5, -0.5,  0.5, -0.5
            ]);
            indices = new Uint16Array([
              0,  1,  2,  0,  2,  3,   // front
              4,  5,  6,  4,  6,  7,   // back
              8,  9,  10, 8,  10, 11,  // top
              12, 13, 14, 12, 14, 15,  // bottom
              16, 17, 18, 16, 18, 19,  // right
              20, 21, 22, 20, 22, 23   // left
            ]);
          } else if (this.type === 'sphere') {
            const radius = 0.5;
            const segments = 16;
            vertices = [];
            indices = [];
            for (let lat = 0; lat <= segments; lat++) {
              const theta = lat * Math.PI / segments;
              const sinTheta = Math.sin(theta);
              const cosTheta = Math.cos(theta);
              for (let lon = 0; lon <= segments; lon++) {
                const phi = lon * 2 * Math.PI / segments;
                const sinPhi = Math.sin(phi);
                const cosPhi = Math.cos(phi);
                const x = radius * cosPhi * sinTheta;
                const y = radius * cosTheta;
                const z = radius * sinPhi * sinTheta;
                vertices.push(x, y, z);
              }
            }
            for (let lat = 0; lat < segments; lat++) {
              for (let lon = 0; lon < segments; lon++) {
                const first = (lat * (segments + 1)) + lon;
                const second = first + segments + 1;
                indices.push(first, second, first + 1);
                indices.push(second, second + 1, first + 1);
              }
            }
            vertices = new Float32Array(vertices);
            indices = new Uint16Array(indices);
          } else if (this.type === 'torus') {
            const radius = 0.3;
            const tubeRadius = 0.1;
            const radialSegments = 16;
            const tubularSegments = 20;
            vertices = [];
            indices = [];
            for (let i = 0; i <= radialSegments; i++) {
              for (let j = 0; j <= tubularSegments; j++) {
                const u = i / radialSegments * Math.PI * 2;
                const v = j / tubularSegments * Math.PI * 2;
                const x = (radius + tubeRadius * Math.cos(v)) * Math.cos(u);
                const y = (radius + tubeRadius * Math.cos(v)) * Math.sin(u);
                const z = tubeRadius * Math.sin(v);
                vertices.push(x, y, z);
              }
            }
            for (let i = 0; i < radialSegments; i++) {
              for (let j = 0; j < tubularSegments; j++) {
                const a = (tubularSegments + 1) * i + j;
                const b = (tubularSegments + 1) * (i + 1) + j;
                indices.push(a, b, a + 1);
                indices.push(b, b + 1, a + 1);
              }
            }
            vertices = new Float32Array(vertices);
            indices = new Uint16Array(indices);
          }
          const vertexBuffer = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
          gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
          const indexBuffer = gl.createBuffer();
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
          gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
          return { vertexBuffer, indexBuffer, vertexCount: indices.length };
        }
        draw(viewMatrix, projectionMatrix, time) {
          gl.useProgram(this.program);
          const modelMatrix = new Float32Array(16);
          // Translation
          modelMatrix[0] = 1; modelMatrix[1] = 0; modelMatrix[2] = 0; modelMatrix[3] = 0;
          modelMatrix[4] = 0; modelMatrix[5] = 1; modelMatrix[6] = 0; modelMatrix[7] = 0;
          modelMatrix[8] = 0; modelMatrix[9] = 0; modelMatrix[10] = 1; modelMatrix[11] = 0;
          modelMatrix[12] = this.position[0];
          modelMatrix[13] = this.position[1];
          modelMatrix[14] = this.position[2];
          modelMatrix[15] = 1;
          // Rotation
          this.rotation = time * 0.5; // Rotate at 0.5 rad/s
          const cos = Math.cos(this.rotation);
          const sin = Math.sin(this.rotation);
          const rotMatrix = new Float32Array([
            cos, 0, sin, 0,
            0, 1, 0, 0,
            -sin, 0, cos, 0,
            0, 0, 0, 1
          ]);
          const modelViewMatrix = new Float32Array(16);
          multiply4x4(viewMatrix, modelMatrix, modelViewMatrix);
          multiply4x4(modelViewMatrix, rotMatrix, modelViewMatrix);
          gl.uniformMatrix4fv(gl.getUniformLocation(this.program, 'uModelViewMatrix'), false, modelViewMatrix);
          gl.uniformMatrix4fv(gl.getUniformLocation(this.program, 'uProjectionMatrix'), false, projectionMatrix);
          const color = this.isGazed ? this.gazeColor : this.color;
          gl.uniform3fv(gl.getUniformLocation(this.program, 'uColor'), color);
          gl.bindBuffer(gl.ARRAY_BUFFER, this.buffers.vertexBuffer);
          const posLoc = gl.getAttribLocation(this.program, 'aPosition');
          gl.enableVertexAttribArray(posLoc);
          gl.vertexAttribPointer(posLoc, 3, gl.FLOAT, false, 0, 0);
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.buffers.indexBuffer);
          gl.drawElements(gl.TRIANGLES, this.buffers.vertexCount, gl.UNSIGNED_SHORT, 0);
        }
      }

      function multiply4x4(a, b, result) {
        for (let i = 0; i < 4; i++) {
          for (let j = 0; j < 4; j++) {
            result[i * 4 + j] = 0;
            for (let k = 0; k < 4; k++) {
              result[i * 4 + j] += a[i * 4 + k] * b[k * 4 + j];
            }
          }
        }
      }

      function createWebGLContext(options) {
        const canvas = document.createElement('canvas');
        document.body.appendChild(canvas);
        return canvas.getContext('webgl', options) || canvas.getContext('experimental-webgl', options);
      }

      class InlineViewerHelper {
        constructor(canvas, referenceSpace) {
          this.canvas = canvas;
          this.referenceSpace = referenceSpace;
        }
      }

      // Scene setup
      scene = new Scene();
      scene.addNode(new ShapeNode({
        position: [-0.5, 1, -1.5], // Cube
        type: 'cube',
        color: [1, 0, 0], // Red
        gazeColor: [0, 1, 0] // Green
      }));
      scene.addNode(new ShapeNode({
        position: [0, 1, -1.5], // Sphere
        type: 'sphere',
        color: [0, 0, 1], // Blue
        gazeColor: [0.5, 0, 0.5] // Purple
      }));
      scene.addNode(new ShapeNode({
        position: [0.5, 1, -1.5], // Torus
        type: 'torus',
        color: [1, 1, 0], // Yellow
        gazeColor: [1, 0.5, 0] // Orange
      }));

      function initXR() {
        xrButton = new WebXRButton({
          onRequestSession: onRequestSession,
          onEndSession: onEndSession,
          textEnterXRTitle: "START AR",
          textXRNotFoundTitle: "AR NOT FOUND",
          textExitXRTitle: "EXIT AR",
        });
        document.querySelector('header').appendChild(xrButton.domElement);

        if (navigator.xr) {
          navigator.xr.isSessionSupported('immersive-ar').then((supported) => {
            xrButton.enabled = supported;
          });
          navigator.xr.requestSession('inline').then(onSessionStarted);
        }
      }

      function onRequestSession() {
        return navigator.xr.requestSession('immersive-ar', {
          optionalFeatures: ['hit-test']
        }).then((session) => {
          xrButton.setSession(session);
          session.isImmersive = true;
          onSessionStarted(session);
        });
      }

      function initGL() {
        if (gl) return;
        gl = createWebGLContext({ xrCompatible: true });
        function onResize() {
          gl.canvas.width = gl.canvas.clientWidth * window.devicePixelRatio;
          gl.canvas.height = gl.canvas.clientHeight * window.devicePixelRatio;
        }
        window.addEventListener('resize', onResize);
        onResize();
        renderer = new Renderer(gl);
        scene.setRenderer(renderer);
      }

      function onSessionStarted(session) {
        xrSession = session;
        session.addEventListener('end', onSessionEnded);
        initGL();
        session.updateRenderState({ baseLayer: new XRWebGLLayer(session, gl) });
        let refSpaceType = session.isImmersive ? 'local' : 'viewer';
        session.requestReferenceSpace(refSpaceType).then((refSpace) => {
          if (session.isImmersive) {
            xrImmersiveRefSpace = refSpace;
            // Request hit-test source for gaze detection
            session.requestReferenceSpace('viewer').then((viewerSpace) => {
              session.requestHitTestSource({ space: viewerSpace }).then((source) => {
                hitTestSource = source;
              });
            });
          } else {
            inlineViewerHelper = new InlineViewerHelper(gl.canvas, refSpace);
          }
          session.requestAnimationFrame(onXRFrame);
        });
      }

      function onEndSession(session) {
        session.end();
      }

      function onSessionEnded(event) {
        if (event.session.isImmersive) {
          xrButton.setSession(null);
          hitTestSource = null;
        }
      }

      function onXRFrame(t, frame) {
        let session = frame.session;
        let refSpace = session.isImmersive ? xrImmersiveRefSpace : inlineViewerHelper.referenceSpace;
        let pose = frame.getViewerPose(refSpace);
        scene.startFrame();
        session.requestAnimationFrame(onXRFrame);
        scene.drawXRFrame(frame, pose);
        scene.endFrame();
      }

      initXR();
    </script>
</body>
</html>
