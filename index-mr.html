<!DOCTYPE html>
<html>
<head>
  <title>Mixed Reality Gallery (Three.js)</title>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Three.js script -->
  <script src="https://unpkg.com/three@0.162.0/build/three.min.js"></script>
  <style>
    body {
      margin: 0;
      font-family: Arial, sans-serif;
    }
    canvas {
      display: block;
    }
    #arButton {
      position: fixed;
      bottom: 20px;
      left: 20px;
      padding: 10px 20px;
      background-color: #007bff;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      z-index: 1000;
    }
    #debugLog {
      position: fixed;
      top: 20px;
      left: 20px;
      background-color: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 10px;
      max-width: 50%;
      max-height: 50%;
      overflow-y: auto;
      z-index: 1000;
      font-family: monospace;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <!-- Button to start AR session -->
  <button id="arButton">Enter AR Mode</button>

  <!-- Debug log display -->
  <div id="debugLog"></div>

  <!-- Custom scripts -->
  <script>
    // Debug logging function
    const debugLog = document.getElementById('debugLog');
    function log(message) {
      debugLog.innerHTML += message + '<br>';
      debugLog.scrollTop = debugLog.scrollHeight;
    }

    // Three.js scene setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 1.6, 0); // Eye height for VR

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true;
    document.body.appendChild(renderer.domElement);

    // Set transparent background for passthrough
    renderer.setClearColor(0x000000, 0);

    // Resize handler
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Add objects
    const cubeGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
    const cubeMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
    const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
    cube.position.set(-2, 1, -3);
    cube.userData = { originalColor: 0xff0000, gazeColor: 0x00ff00 };
    scene.add(cube);

    const sphereGeometry = new THREE.SphereGeometry(0.5, 32, 32);
    const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff });
    const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
    sphere.position.set(0, 1, -3);
    sphere.userData = { originalColor: 0x0000ff, gazeColor: 0x800080 };
    scene.add(sphere);

    const torusGeometry = new THREE.TorusGeometry(0.3, 0.1, 16, 100);
    const torusMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
    const torus = new THREE.Mesh(torusGeometry, torusMaterial);
    torus.position.set(2, 1, -3);
    torus.userData = { originalColor: 0xffff00, gazeColor: 0xffa500 };
    scene.add(torus);

    // Add rotation animations
    function animateObjects() {
      cube.rotation.y += 0.02;
      sphere.rotation.y += 0.02;
      torus.rotation.y += 0.02;
    }

    // Add text (using Three.js TextGeometry)
    const fontLoader = new THREE.FontLoader();
    fontLoader.load('https://unpkg.com/three@0.162.0/examples/fonts/helvetiker_regular.typeface.json', (font) => {
      const textGeometry = new THREE.TextGeometry('MR Gallery Demo', {
        font: font,
        size: 0.5,
        height: 0.1,
      });
      const textMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
      const textMesh = new THREE.Mesh(textGeometry, textMaterial);
      textMesh.position.set(-1.5, 2, -2);
      scene.add(textMesh);
    });

    // Gaze interaction using raycasting
    const raycaster = new THREE.Raycaster();
    const direction = new THREE.Vector3(0, 0, -1); // Forward direction
    let lastIntersected = null;

    function handleGaze() {
      // Update raycaster from camera
      raycaster.setFromCamera({ x: 0, y: 0 }, camera);
      const intersects = raycaster.intersectObjects([cube, sphere, torus]);

      if (intersects.length > 0) {
        const intersected = intersects[0].object;
        if (intersected !== lastIntersected) {
          if (lastIntersected) {
            lastIntersected.material.color.setHex(lastIntersected.userData.originalColor);
          }
          intersected.material.color.setHex(intersected.userData.gazeColor);
          lastIntersected = intersected;
        }
      } else {
        if (lastIntersected) {
          lastIntersected.material.color.setHex(lastIntersected.userData.originalColor);
          lastIntersected = null;
        }
      }
    }

    // WebXR controller for teleportation
    const controller = renderer.xr.getController(1); // Right controller
    scene.add(controller);

    const teleportTarget = new THREE.Mesh(
      new THREE.CircleGeometry(0.3, 32),
      new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.5 })
    );
    teleportTarget.rotation.x = -Math.PI / 2;
    teleportTarget.visible = false;
    scene.add(teleportTarget);

    let isSelecting = false;
    controller.addEventListener('selectstart', () => {
      isSelecting = true;
    });
    controller.addEventListener('selectend', () => {
      if (teleportTarget.visible) {
        const cameraGroup = renderer.xr.getCamera(camera).parent;
        cameraGroup.position.set(teleportTarget.position.x, 0, teleportTarget.position.z);
      }
      isSelecting = false;
      teleportTarget.visible = false;
    });

    function handleTeleport() {
      if (!isSelecting) return;

      const controllerPose = renderer.xr.getController(1);
      const raycaster = new THREE.Raycaster();
      raycaster.set(controllerPose.position, controllerPose.getWorldDirection(new THREE.Vector3()));
      const intersects = raycaster.intersectObject(new THREE.Mesh(new THREE.PlaneGeometry(100, 100), new THREE.MeshBasicMaterial()), true);

      if (intersects.length > 0) {
        teleportTarget.position.copy(intersects[0].point);
        teleportTarget.visible = true;
      } else {
        teleportTarget.visible = false;
      }
    }

    // Animation loop
    function animate() {
      renderer.setAnimationLoop((time, frame) => {
        animateObjects();
        handleGaze();
        handleTeleport();
        renderer.render(scene, camera);
      });
    }

    // Start AR session
    document.addEventListener('DOMContentLoaded', () => {
      const arButton = document.getElementById('arButton');

      log('Checking WebXR support...');
      if (!navigator.xr) {
        log('WebXR not supported in this browser.');
        arButton.textContent = 'WebXR Not Supported';
        arButton.disabled = true;
        return;
      }

      navigator.xr.isSessionSupported('immersive-ar').then((supported) => {
        if (supported) {
          log('immersive-ar is supported.');
          arButton.style.display = 'block';
          arButton.addEventListener('click', () => {
            log('Requesting immersive-ar session...');
            navigator.xr.requestSession('immersive-ar').then(async (session) => {
              log('immersive-ar session started successfully.');
              renderer.xr.setSession(session);
              setTimeout(() => {
                log('Passthrough should be active now.');
                arButton.style.display = 'none';
              }, 2000);
              animate();
            }).catch((err) => {
              log('Failed to start AR session: ' + err.message);
              alert('Failed to start AR mode. Ensure passthrough is enabled and try again in Wolvic browser.');
            });
          });
        } else {
          log('immersive-ar not supported.');
          arButton.textContent = 'AR Not Supported';
          arButton.disabled = true;
        }
      }).catch((err) => {
        log('Error checking immersive-ar support: ' + err.message);
        arButton.textContent = 'WebXR Error';
        arButton.disabled = true;
      });
    });
  </script>
</body>
</html>
